/*
一组8个单bit寄存器，状态分别只能是1和0。每个时钟周期，各寄存器状态都会按以下规则更改：
- 如果一个寄存器左右相邻寄存器全是0或全是1，则该寄存器在一个时钟周期后，其状态为1
- 否则，其状态为0
（注意，最两边的寄存器，无法有左右都相邻寄存器。）
 
给定8个寄存器初始状态，及时钟周期数量cycleNum，求 cycleNum 个时钟周期后的所有寄存器状态。
 
示例 1：
输入：regs = [0,1,0,1,1,0,0,1], cycleNum = 7
输出：[0,0,1,1,0,0,0,0]
解释：
下表概述了寄存器每个时钟周期状态，,其中右边界的 1 按规则在第一个周期后变为 0:
Tick 0: [0, 1, 0, 1, 1, 0, 0, 1]
Tick 1: [0, 1, 1, 0, 0, 0, 0, 0]
Tick 2: [0, 0, 0, 0, 1, 1, 1, 0]
Tick 3: [0, 1, 1, 0, 0, 1, 0, 0]
Tick 4: [0, 0, 0, 0, 0, 1, 0, 0]
Tick 5: [0, 1, 1, 1, 0, 1, 0, 0]
Tick 6: [0, 0, 1, 0, 1, 1, 0, 0]
Tick 7: [0, 0, 1, 1, 0, 0, 0, 0]
所以7个时钟周期后的寄存器状态为：[0, 0, 1, 1, 0, 0, 0, 0]
示例 2：
输入：regs = [1,0,0,1,0,0,1,0], cycleNum = 1000000000
输出：[0,0,1,1,1,1,1,0] 
解释：必须考虑大的 cycleNum 情况下的处理，全遍历(O(n)时间复杂度)方法通过的用例会很少。
 
提示：
- 寄存器数量固定为8个
- 给定初始状态只会为0或1
- 1 <= cycleNum <= 10^9
*/

/*
思路：题目中cycleNum最大为10^9，数据较大，而只有8个bit位变化，所以必然是周期性的规律能减少运行量。
根据初始值动态的生成table表，用cycleNum取余，加个偏移即可找到结果。
*/
#include <stdio.h>

int main()
{
    int regs[8] = {1,0,0,1,0,0,1,0}; //初始值
    int cycleNum = 1000000000;

    int table[14][8] = {{0}};
    int c = 0;   
    int b[8];
    while(c < 14) { // 测试后发现不论左右两个值为多少，循环周期总为14，所以设置固定值即可
        for(int i = 1; i < 7; i++) {
            if(regs[i - 1] == regs[i + 1]) {
                b[i] = 1;
            } else {
                b[i] = 0;
            }
        }
        b[0] = 0;
        b[7] = 0;

        memcpy(regs, b, sizeof(int) * 8);
        memcpy(table[c], b, sizeof(int) * 8);
   
        printf("[cycle:%4d]   ", c + 1);
        for(int i = 0; i < 8; i++) {
            printf("%d, ", regs[i]);
        }
        printf("\n");
        c++;
    }

    printf("cycleNum = %d, result = ", cycleNum);
    for(int i = 0; i < 8; i++) {
        int tmp = ((cycleNum % 14 - 1) + 14) % 14;
        printf("%d ", table[tmp][i]);
    }

    return 0;
}
